// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

// 2 ^ 2 = 4,  2 ^ 3 = 8,   2 ^ 4 = 16,  2 ^ 5 = 32
// 3 ^ 2 = 9,  3 ^ 3 = 27,  3 ^ 4 = 81,  3 ^ 5 = 243
// 4 ^ 2 = 16, 4 ^ 3 = 64,  4 ^ 4 = 256, 4 ^ 5 = 1024
// 5 ^ 2 = 25, 5 ^ 3 = 125, 5 ^ 4 = 625, 5 ^ 5 = 3125
// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

// How many distinct terms are in the sequence generated by a ^ b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

import { Factor } from '../../math/factor';
const primeFactorCount = Factor.primeFactorCount;

// exponentiation by b is identical to multiplying the count of factors by b
function fcExponentiate(count, exp) {
  const rv = {};
  Object.keys(count).forEach(p => {
    if (count[p]) {
      rv[p] = count[p] * exp;
    }
  });
  return rv;
}

// generate a unique signature for a given factor count
function fcSignature(count) {
  return Object.keys(count)
    .map(f => parseInt(f, 10))
    .sort()
    .map(f => `${f}:${count[f]}`)
    .join(';');
}

export default function euler029() {
  const seen = {};
  for (let a = 2; a <= 100; a++) {
    const fc = primeFactorCount(a);
    for (let b = 2; b <= 100; b++) {
      const exponentiated = fcExponentiate(fc, b);
      const signature = fcSignature(exponentiated);
      seen[signature] = true;
    }
  }
  return Object.keys(seen).length;
}
